% ------ headers globales -------------
\documentclass[11pt, a4paper, twoside]{article}
\usepackage{header}
\usepackage{config}
% -------------------------------------
\begin{document}

%-- Carátula --
\clearpage{\pagestyle{empty}\input{caratula}}

%-- Índice --
\clearpage{%
  \pagestyle{empty}\tableofcontents%
  \vspace{3cm}%
  \cleardoublepage%
}
%-- A partir de aquí, pongo el contador de páginas en 1 --
\setcounter{page}{1}

%
%-- Sección: Vulnerabilidades locales
%
\index{Vulnerabilidades Locales}
\section{Vulnerabilidades Locales}
\subsection{Datos mal protegidos}
\subsubsection{Descripción}
A partir de esta vulnerabilidad, una aplicación maliciosa podría 
acceder a los datos sensibles del usuario. 

Para analizar la aplicación en busca de esta vulnerabilidad, se desempaquetó el archivo \textbf{<<BadBrowser.apk>>}, utilizando para ello la herramienta \textbf{apktool}\footnote{Repositorio oficial de apktool: \url{http://code.google.com/p/android-apktool/}}, mediante el comando ``\texttt{apktool decode BadBrowser.apk}''. Esto generó un directorio BadBrowser, en donde se encontraron los siguientes archivos:
\begin{center}
\texttt{AndroidManifest.xml apktool.yml assets original res smali}
\end{center}

Se analizó luego el archivo \textbf{<<AndroidManifest.xml>>}, el cual se encuentra transcripto en \fig{AndroidManifest}. Uno de los primeros detalles a tener en cuenta, es la versión mínima de SDK para la cual fue producida la aplicación. En este caso, es posible obtener esa información a partir de la propiedad {\color{red}\textbf{platformBuildVersionCode}} del tag manifest. Esta aplicación fue hecha para la versión 16 del SDK, lo que permite deducir que cualquier componente al que no se le asignen \textbf{permisos explícitos}, o cualquier provider al que no se le asigne la propiedad \textbf{exported} en \emph{false}, es accesible públicamente\footnote{``Any application can access public components that are not explicitly assigned an access permission in their manifest definition. Android content provider are exported by default for applications that set either android:minSdkVersion or android:targetSdkVersion to "16" or lower. (\url{http://www.hpenterprisesecurity.com/vulncat/en/vulncat/java/android_bad_practices_missing_exported_flag_or_component_permission.html})}.

\begin{wrapfigure}{r}{0.3\textwidth}
%\vspace{-20pt}
\begin{center}
\includegraphics[scale=0.45]{android-provider.png}
\end{center}
\vspace{-20pt}
\caption{Provider}
\label{fig:android-provider}
\vspace{-30pt}
\end{wrapfigure}

Se encontró un provider {\color{blue}\texttt{``ar.sadosky.browser.history\_provider''}}, el cual tiene definida la propiedad \texttt{{\color{red}android:exported}={\color{blue}``true''}}, lo que significa que se exporta públicamente, y en donde la propiedad \texttt{\color{red}android:readPermission} no se encuentra definida. De esta forma, la aplicación está exponiendo \emph{datos sensibles} (el historial web del usuario), de forma pública, con \emph{permisos normales}, es decir que cualquier otra aplicación se encuentra en condiciones de leer el historial del usuario.

Para saber cómo una aplicación maliciosa podría aprovechar esta vulnerabilidad, es necesario entender cómo está definido el \emph{provider} dentro de la aplicación que se quiere vulnerar. Para ello, es útil primero entender qué es lo que viene a representar un \emph{content provider}, y cómo es que las aplicaciones acceden al mismo. En \fig{android-provider} se puede apreciar una representación básica de un provider en android, que no resulta ser más que una abstracción para una base de datos. 

\begin{figure}[H]
\lstinputlisting[language=XML_android]{AndroidManifest.xml}
\caption{AndroidManifest.xml}
\label{fig:AndroidManifest}
\end{figure}

En el código del programa, cada \texttt{Content Provider} está representado por una clase que extiende a la clase \textbf{\emph{ContentProvider}}\footnote{Clase nativa del SDK de Android: \url{http://developer.android.com/reference/android/content/ContentProvider.html}}, por lo que buscando dentro de la carpeta \textbf{<<smali>>} del BadBrowser desempaquetado, podemos encontrar el archivo ``\texttt{./ar/sadosky/badbrowser/HistoryProvider.smali}'', el cual contiene información sobre el provider en cuestión. 

Dado que los archivos \texttt{smali} son particularmente dificultosos de leer, otra opción es utilizar el programa \textbf{dex2jar}\footnote{Este programa sirve para transformar los binarios de Android en binarios de Java. Repositorio oficial: \url{http://code.google.com/p/dex2jar/}} para obtener un archivo \textbf{<<BadBrowser.jar>>} a partir del \texttt{apk}. Para ello, corremos el comando ``\texttt{dex2jar BadBrowser.apk}''. El binario obtenido puede ser visualizado, a su vez, con un decompilador de java, por ejemplo \textbf{jd-gui}\footnote{http://jd.benow.ca/\#jd-gui}, ejecutando ``\texttt{jd-gui BadBrowser-dex2jar.jar}''. Se realizaron estos pasos, obteniendo el código de la clase \textbf{\emph{HistoryProvider}}, como se puede apreciar en \fig{historyprovider-jdgui}. De aquí es de donde se obtuvo la URI a través de la cual el programa hace los requests, ``\texttt{\color{blue}content://ar.sadosky.browser.historyprovider/history}''.

\begin{center}
\begin{figure}[H]
\includegraphics[scale=0.475]{historyprovider-jdgui.png}
\caption{\texttt{HistoryProvider.class} en \textbf{JD-GUI}}
\label{fig:historyprovider-jdgui}
\end{figure}
\end{center}

\subsubsection{Prueba de Concepto}
\begin{verbatim}
$ adb shell content query --uri "content://ar.sadosky.browser.history_provider/history"
Row: 0 url_visited=about:blank
\end{verbatim}

\subsection{Componentes mal exportados}

%
%-- Sección: Vulnerabilidades de Red
%
\clearpage
\index{Vulnerabilidades de Red}
\section{Vulnerabilidades de Red}
\subsection{Activo}
\subsection{Pasivo}

%
%-- Sección: Vulnerabilidades Remotas
%
\clearpage
\index{Vulnerabilidades Remotas}
\section{Vulnerabilidades Remotas}


\end{document}